<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>IFRAS — Sécurité des systèmes d’authentification</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      background-color: #050b1e;
      color: #e6e6e6;
      line-height: 1.75;
    }

    header {
      background: linear-gradient(180deg, #0a1a3a, #050b1e);
      padding: 30px 20px;
      border-bottom: 1px solid #1b2555;
    }

    .header-container {
      max-width: 1100px;
      margin: auto;
      display: flex;
      align-items: center;
      gap: 25px;
    }

    .logo {
      width: 90px;
    }

    nav {
      background-color: #070f2b;
      border-bottom: 1px solid #1b2555;
    }

    nav ul {
      max-width: 1100px;
      margin: auto;
      padding: 0;
      list-style: none;
      display: flex;
      gap: 30px;
    }

    nav li {
      padding: 14px 0;
    }

    nav a {
      color: #d1d5db;
      text-decoration: none;
      font-size: 14px;
    }

    nav a:hover {
      color: white;
    }

    main {
      max-width: 950px;
      margin: auto;
      padding: 80px 20px;
    }

    h1 {
      font-size: 36px;
      margin-bottom: 15px;
    }

    .article-meta {
      font-size: 14px;
      color: #9ca3af;
      margin-bottom: 50px;
    }

    .abstract {
      background: #070f2b;
      border: 1px solid #1b2555;
      border-radius: 14px;
      padding: 30px;
      margin-bottom: 70px;
    }

    .abstract h2 {
      margin-top: 0;
      font-size: 20px;
      color: #c7d2fe;
    }

    section {
      margin-bottom: 20px;
    }

    section h2 {
      font-size: 24px;
      margin-bottom: 4px;
      color: #c7d2fe;
    }

    p {
      font-size: 15px;
      color: #d1d5db;
    }

    .split {
      display: flex;
      gap: 20px;
      align-items: center;
      margin: 10px 0;
    }

    .split.reverse {
      flex-direction: row-reverse;
    }

    .split img {
      width: 50%;
      border-radius: 12px;
      border: 1px solid #1b2555;
    }

    .split .text {
      width: 55%;
    }

    .figure {
      margin: 60px 0;
      text-align: center;
    }

    .figure img {
      max-width: 100%;
      border-radius: 12px;
      border: 1px solid #1b2555;
    }

    .caption {
      font-size: 13px;
      color: #9ca3af;
      margin-top: 10px;
    }

    .equation {
      background: #020617;
      border: 1px solid #1b2555;
      padding: 25px;
      border-radius: 12px;
      font-family: "Courier New", monospace;
      text-align: center;
      margin: 40px 0;
      color: #c7d2fe;
      font-size: 15px;
    }

    .note {
      background: #050b1e;
      border-left: 4px solid #4f6bed;
      padding: 20px 25px;
      margin: 40px 0;
      color: #aab3d6;
      font-size: 14px;
    }

    footer {
      background-color: #020617;
      border-top: 1px solid #1b2555;
      padding: 30px 20px;
      font-size: 12px;
      color: #6b7280;
    }

    footer .footer-container {
      max-width: 1100px;
      margin: auto;
    }

    @media (max-width: 900px) {
      .split, .split.reverse {
        flex-direction: column;
      }
      .split img, .split .text {
        width: 100%;
      }
    }
    .entropy-table {
  width: 100%;
  border-collapse: collapse;
  margin: 50px 0;
  background-color: #070f2b;
  border: 1px solid #1b2555;
  border-radius: 12px;
  overflow: hidden;
  font-size: 14px;
}

.entropy-table th,
.entropy-table td {
  padding: 16px 14px;
  text-align: center;
  border-bottom: 1px solid #1b2555;
}

.entropy-table thead {
  background: linear-gradient(180deg, #0a1a3a, #070f2b);
}

.entropy-table th {
  color: #c7d2fe;
  font-weight: 600;
}

.entropy-table td {
  color: #d1d5db;
}

.entropy-table td span {
  font-size: 12px;
  color: #9ca3af;
}

.entropy-table tbody tr:hover {
  background-color: rgba(79, 107, 237, 0.08);
}

  </style>
  
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
  
</head>

<body>

<header>
  <div class="header-container">
    <img src="../logo.png" alt="Logo IFRAS" class="logo">
    <h1>Publications scientifiques</h1>
  </div>
</header>

<nav>
  <ul>
    <li><a href="../index.html">Accueil</a></li>
    <li><a href="../recherche.html">Recherche</a></li>
    <li><a href="../programmes.html">Programmes</a></li>
    <li><a href="../publications.html">Publications</a></li>
    <li><a href="#">Recrutement</a></li>
    <li><a href="#">Contact</a></li>
  </ul>
</nav>

<main>

<h1>Sécurité des systèmes d’authentification face à l’augmentation des capacités de calcul assistées par IA</h1>

<div class="article-meta">
Département Systèmes & Infrastructures Numériques — IFRAS<br>
Publication institutionnelle — Septembre 2024
</div>

<div class="abstract">
<h2>Résumé</h2>
<p>
L’authentification par mot de passe demeure l’un des mécanismes de contrôle d’accès
les plus largement déployés dans les infrastructures critiques civiles et scientifiques.
Cependant, l’augmentation rapide des capacités de calcul, combinée aux progrès
des modèles d’intelligence artificielle appliqués à l’optimisation des attaques,
réduit significativement la durée de vie opérationnelle de schémas historiquement jugés sûrs.
Cette étude présente une analyse quantitative de ces évolutions et examine les ajustements
progressifs mis en œuvre dans les politiques internes de l’IFRAS.
</p>
</div>

<section>
<h2>1. Évolution historique des schémas d’authentification</h2>

<p>
Les premiers systèmes d’authentification informatisés, déployés à grande échelle à partir des années 1980 et 1990, 
ont été conçus dans un contexte technologique et opérationnel très différent de celui d’aujourd’hui. Les modèles de 
menace alors retenus reposaient principalement sur l’idée que l’attaquant devait disposer soit d’un accès physique 
prolongé aux machines, soit de ressources matérielles lourdes, coûteuses et rares. Les attaques à distance étaient 
limitées par la faible interconnexion des systèmes, l’absence d’Internet grand public et des débits réseau très réduits.
</p>

<div class="split">
  <div class="text">
    <p>
   Dans les environnements institutionnels de l’époque (universités, administrations, grandes entreprises), les systèmes étaient majoritairement fermés, 
   centralisés et administrés localement. Les comptes utilisateurs étaient hébergés sur des mainframes ou des serveurs Unix partagés, accessibles depuis des terminaux internes. 
   Dans ce cadre, le risque principal était l’usurpation par un utilisateur légitime ou la compromission locale, bien plus que l’attaque automatisée à grande échelle.
   C’est dans ce contexte que les politiques de mots de passe ont été définies. Des schémas courts, combinant lettres et chiffres sur une longueur limitée (souvent 6 à 8 caractères),
   étaient considérés comme suffisants. Cette perception était renforcée par les contraintes d’ergonomie (claviers de terminaux, mémorisation humaine) et par le coût des attaques par force brute.
    </p>
  </div>
  <img src="/Assets/articles/article04 image01.jpg" alt="Sécurité image">
  </div>

<p>
Au début des années 2000, un tel espace de recherche dépassait largement les capacités de calcul accessibles dans un cadre réaliste. Les processeurs grand public fonctionnaient à 
quelques centaines de MHz, et les architectures parallèles restaient réservées à des centres de calcul spécialisés. Une attaque exhaustive sur un tel espace pouvait théoriquement 
nécessiter des années, voire des décennies, même en supposant une vérification rapide des tentatives. De plus, les mécanismes de stockage des mots de passe reposaient souvent sur des 
fonctions de hachage cryptographique conçues pour être relativement coûteuses en calcul (comme DES-based crypt, puis MD5 ou SHA-1 dans certains contextes), ce qui ralentissait encore les 
tentatives hors ligne. La combinaison d’un espace de recherche large, d’une puissance de calcul limitée et d’un faible niveau d’exposition réseau rendait donc ces schémas acceptables 
au regard des risques perçus.
</p>

<p>
Cependant, ces hypothèses se sont progressivement effondrées avec la généralisation d’Internet, l’explosion de la puissance de calcul (CPU multicœurs, GPU, ASIC), la démocratisation du calcul 
distribué et l’industrialisation des attaques automatisées. Ce qui constituait autrefois une barrière économique ou technique est devenu aujourd’hui trivialement accessible, rendant obsolètes 
les modèles de sécurité hérités de cette période. Mais alors, comment bien se portéger et être certains de la robustesse de son mot de passe ? 
</p>
</section>

<section>
<h2>2. Différents types d'attaque</h2>
<p>
Il existe plusieurs catégories d’attaques visant à compromettre les mécanismes d’authentification par mot de passe,
chacune exploitant des leviers techniques, statistiques ou humains distincts.
</p>

<ul>
  <li>
    <strong>Attaque par force brute :</strong>
    cette méthode consiste à tester systématiquement l’ensemble des combinaisons possibles jusqu’à l’obtention
    du mot de passe correct. L’efficacité de cette approche dépend directement de la longueur du mot de passe
    et de la taille du jeu de caractères utilisé. Plus ces paramètres sont élevés, plus l’espace de recherche
    croît exponentiellement, rendant l’attaque coûteuse en temps et en ressources.
  </li>

  <li>
    <strong>Attaque par dictionnaire :</strong>
    elle repose sur l’exploitation de listes de mots de passe couramment utilisés, issues de bases de données
    compromises ou de modèles statistiques du comportement humain. Un mot de passe réellement aléatoire
    présente une probabilité extrêmement faible de figurer dans ces dictionnaires, ce qui réduit fortement
    l’efficacité de cette technique.
  </li>

  <li>
    <strong>Attaque par tables arc-en-ciel :</strong>
    cette approche utilise des bases pré-calculées reliant des mots de passe à leurs empreintes cryptographiques.
    Elle n’est applicable que si l’attaquant a accès aux mots de passe tels qu’ils sont stockés après hachage,
    généralement à la suite d’une compromission de base de données. L’ajout d’un sel cryptographique
    rend ce type d’attaque largement inefficace.
  </li>

  <li>
    <strong>Attaque par ingénierie sociale :</strong>
    elle exploite le facteur humain, soit en déduisant le mot de passe à partir d’informations personnelles,
    soit en incitant la victime à le divulguer volontairement, notamment par des campagnes de phishing
    ou de manipulation psychologique.
  </li>

  <li>
    <strong>Attaques logicielles et système :</strong>
    ces attaques tirent parti de vulnérabilités applicatives ou système. En cas de compromission,
    il devient parfois possible d’extraire des mots de passe depuis la mémoire vive, des fichiers temporaires
    ou des journaux insuffisamment protégés.
  </li>
</ul>

<p>
Dans une analyse strictement cryptographique, excluant les faiblesses humaines et les compromissions système,
le vecteur d’attaque le plus dominants reste la force brute. Ce sont donc ces approches qui constituent les 
principales références pour l’évaluation quantitative de la robustesse des mots de passe. Voyons maintenant comme

</p>

</section>
  
<section>
<h2>2. Calcul de l'entropie</h2>

<p>
Premèrement, nous devons définir la notion de « force » d’un mot de passe : On désigne communément par la « force » d’un mot de passe sa capacité à résister à une attaque par énumération exhaustive, 
plus connue sous le nom d’attaque par force brute. Ce type d’attaque consiste à tester systématiquement toutes les combinaisons possibles jusqu’à trouver la bonne. D’un point de vue conceptuel, la force d’un mot 
de passe peut être rapprochée de celle d’un mécanisme cryptographique : elle est comparable à la taille d’une clé de chiffrement. Plus cette « clé » est grande, plus l’effort nécessaire pour la casser augmente.
</p>

<p>
La robustesse d’un mot de passe est généralement exprimée à l’aide de l’entropie de Shannon, mesurée en bits. Cette mesure permet de quantifier l’imprévisibilité d’un mot de passe de manière compacte, 
sans avoir à manipuler directement des nombres de combinaisons souvent astronomiques. L’entropie représente la quantité d’information nécessaire pour deviner un mot de passe choisi aléatoirement dans 
un ensemble donné. Plus l’entropie est élevée, plus le mot de passe est théoriquement difficile à deviner. Cependant, il est crucial de souligner que l’entropie n’est qu’une mesure théorique. 
Un mot de passe peut afficher une entropie élevée sur le papier tout en étant extrêmement faible en pratique. Par exemple, "Password123*" respecte de nombreuses règles de complexité (majuscules, minuscules, 
chiffres, caractères spéciaux), mais reste trivial à casser car il repose sur des motifs humains largement intégrés aux dictionnaires d’attaque modernes.
C’est pourquoi la génération réellement aléatoire des mots de passe est un facteur déterminant de leur sécurité effective.  
</p>

<p>
Cette entropie se calcule à partir de la longueur du mot de passe (L), aisni que la taille du jeu de caractères utilisé (B), aussi appelée pool.
La formule est la suivante :

<div class="equation">
\[ E = L \times \log_2(B) \]
</div>
</p>
  
<p>
  <ul>
  <li>E est l’entropie en bits</li>
  <li>L est le nombre de caractères du mot de passe</li>
  <li>B est le nombre de caractères distincts possibles à chaque position</li>
  </ul>
</p>
<p>
Voici un tableau représantant l'entropie de différents mots de passes en fonction du nombre de caractères utilisés et du nombre de pools possibles :
</p>​

  <table class="entropy-table">
  <thead>
    <tr>
      <th>Base / Longueur</th>
      <th>8 caractères</th>
      <th>12 caractères</th>
      <th>15 caractères</th>
      <th>18 caractères</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Base 10</strong><br><span>(chiffres)</span></td>
      <td>26 bits</td>
      <td>39 bits</td>
      <td>49 bits</td>
      <td>59 bits</td>
    </tr>
    <tr>
      <td><strong>Base 26</strong><br><span>(minuscules)</span></td>
      <td>37 bits</td>
      <td>56 bits</td>
      <td>70 bits</td>
      <td>84 bits</td>
    </tr>
    <tr>
      <td><strong>Base 36</strong><br><span>(minuscules + chiffres)</span></td>
      <td>41 bits</td>
      <td>62 bits</td>
      <td>77 bits</td>
      <td>93 bits</td>
    </tr>
    <tr>
      <td><strong>Base 52</strong><br><span>(minuscules + majuscules)</span></td>
      <td>45 bits</td>
      <td>68 bits</td>
      <td>85 bits</td>
      <td>102 bits</td>
    </tr>
    <tr>
      <td><strong>Base 62</strong><br><span>(minuscules + majuscules + chiffres)</span></td>
      <td>47 bits</td>
      <td>71 bits</td>
      <td>89 bits</td>
      <td>107 bits</td>
    </tr>
    <tr>
      <td><strong>Base 85</strong><br><span>(alphabet étendu + caractères spéciaux)</span></td>
      <td>51 bits</td>
      <td>77 bits</td>
      <td>96 bits</td>
      <td>115 bits</td>
    </tr>
  </tbody>
</table>


<p>
  Nous avons donc une première mesure possible d'estimation de robustesse d'un mot de passe. Ceci étant dis, il est possible de développer légèrement ces équations. En effet il faut savoir 
  que l'on peut déterminer le nombre total de combinaisons possibles par la formule :

    <div class="equation">
    \[ C = B^L \]
    </div>
 </p> 
  
<p>
  <ul>
  <li>C est le nombre total de combinaisons possibles</li>
  <li>L est le nombre de caractères du mot de passe</li>
  <li>B est le nombre de caractères distincts possibles à chaque position</li>
  </ul>
</p>
    
<p>
  Voici le même tableau, mais représentant cette fois le nombre total de combinaisons possibles en fonction du nombre de caractères utilisés et du nombre de pools possibles :​
</p>

    
  <table class="entropy-table">
  <thead>
    <tr>
      <th>Base / Longueur</th>
      <th>8 caractères</th>
      <th>12 caractères</th>
      <th>15 caractères</th>
      <th>18 caractères</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Base 10</strong><br><span>(chiffres)</span></td>
      <td>100,000,000</td>
      <td>1,000,000,000,000</td>
      <td>1.00e+15</td>
      <td>1.00e+18</td>
    </tr>
    <tr>
      <td><strong>Base 26</strong><br><span>(minuscules)</span></td>
      <td>208,827,064,576</td>
      <td>9.54e+16</td>
      <td>1.67e+21</td>
      <td>2.94e+25</td>
    </tr>
    <tr>
      <td><strong>Base 36</strong><br><span>(minuscules + chiffres)</span></td>
      <td>2,821,109,907,456</td>
      <td>4.73e+18</td>
      <td>2.21e+23</td>
      <td>1.03e+28</td>
    </tr>
    <tr>
      <td><strong>Base 52</strong><br><span>(minuscules + majuscules)</span></td>
      <td>53,459,728,531,456</td>
      <td>3.90e+20</td>
      <td>5.49e+25</td>
      <td>7.72e+30</td>
    </tr>
    <tr>
      <td><strong>Base 62</strong><br><span>(minuscules + majuscules + chiffres)</span></td>
      <td>2.18e+14</td>
      <td>3.22e+21</td>
      <td>7.68e+26</td>
      <td>1.83e+32</td>
    </tr>
    <tr>
      <td><strong>Base 85</strong><br><span>(alphabet étendu + caractères spéciaux)</span></td>
      <td>2.04e+15</td>
      <td>9.24e+22</td>
      <td>5.09e+28</td>
      <td>2.80e+34</td>
    </tr>
  </tbody>
</table>

  
<p>
Par conséquant nous pouvons relier ce nombre avec l’entropie dans une seule et même équations :
  <div class="equation">
  \[ E = \log_2(C) \]
  </div>
</p>

</section>

<section>
<h2>4. Temps estimé de cassage</h2>
<p>
Nous pouvons grâce à cette entropie, en déuire le temps estimé de cassage. La complexité d’un mot de passe prend tout son sens lorsqu’on la relie à un temps de cassage estimé. 
Celui-ci dépend non seulement de l’entropie, mais aussi de la puissance de calcul disponible pour l’attaquant. Une estimation simplifiée du temps nécessaire pour casser un mot de passe est donnée par 
la formule :

  <div class="equation">
  \[ T = \frac{2^E}{R} \]
  </div>
</p>
<p>
  <ul>
  <li>T est le temps moyen nécessaire (en secondes)</li>
  <li>E est l’entropie en bits</li>
  <li>R est le nombre de tentatives par seconde</li>
   </ul>
</p>	​
<p>
  Les systèmes modernes de craquage, notamment basés sur GPU, peuvent atteindre des milliards, voire des trillions de tentatives par seconde pour certains algorithmes mal protégés. 
  Cela rend les mots de passe courts extrêmement vulnérables, même s’ils paraissent complexes. En réutilisant les deux même tableaux utilisés précédémment, voici l'estimation du temps 
  qu'il faudrait pour déchiffrer un mot de passe, avec un valeur arbitraire d'un milliard de tentative par seconde (ce qui est déjà énorme) :
</p>

      <table class="entropy-table">
  <thead>
    <tr>
      <th>Base / Longueur</th>
      <th>8 caractères</th>
      <th>12 caractères</th>
      <th>15 caractères</th>
      <th>18 caractères</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Base 10</strong><br><span>(chiffres)</span></td>
      <td>Instantanément</td>
      <td>17 minutes</td>
      <td>12 jours</td>
      <td>3.17e+1 années</td>
    </tr>
    <tr>
      <td><strong>Base 26</strong><br><span>(minuscules)</span></td>
      <td>3 minutes</td>
      <td>3.03e+0 années</td>
      <td>5.32e+4 années</td>
      <td>Éternité</td>
    </tr>
    <tr>
      <td><strong>Base 36</strong><br><span>(minuscules + chiffres)</span></td>
      <td>47 minutes</td>
      <td>1.50e+2 années</td>
      <td>7.01e+6 années</td>
      <td>Éternité</td>
    </tr>
    <tr>
      <td><strong>Base 52</strong><br><span>(minuscules + majuscules)</span></td>
      <td>15 heures</td>
      <td>1.24e+4 années</td>
      <td>Éternité</td>
      <td>Éternité</td>
    </tr>
    <tr>
      <td><strong>Base 62</strong><br><span>(minuscules + majuscules + chiffres)</span></td>
      <td>3 jours</td>
      <td>1.02e+5 années</td>
      <td>Éternité</td>
      <td>Éternité</td>
    </tr>
    <tr>
      <td><strong>Base 85</strong><br><span>(alphabet étendu + caractères spéciaux)</span></td>
      <td>24 jours</td>
      <td>2.93e+6 années</td>
      <td>Éternité</td>
      <td>Éternité</td>
    </tr>
  </tbody>
</table>

</section>

<section>
<h2>4. Analyse et conclusion</h2>

  
<div class="split reverse">
  <div class="text">
  
<p>
Ce graphique montre l’évolution de l’entropie en fonction de la taille du pool de caractères utilisé, pour différentes longueurs de mot de passe (8, 12, 15 et 18 caractères).
</p>

<p>
On observe que, quelle que soit la longueur du mot de passe, l’entropie augmente lorsque le nombre de caractères possibles dans le pool augmente. Cela signifie que plus l’alphabet 
utilisé est riche (minuscules, majuscules, chiffres, caractères spéciaux, etc.), plus le mot de passe est difficile à deviner.
</p>

<p>
De plus, à pool constant, les courbes associées aux longueurs plus élevées sont systématiquement au-dessus des autres. Par exemple, pour un même pool, un mot de passe de 18 caractères 
possède une entropie bien plus importante qu’un mot de passe de 8 caractères. L’écart entre les courbes s’accentue lorsque le pool devient plus grand, montrant un effet cumulatif entre
longueur et diversité des caractères.</p>

</div>
<img src="/Assets/articles/article04 image02.png" alt="Entopie en fonction du nombre de pool">
</div>

<div class="split">
  <div class="text">

<p>
Ce graphique présente l’évolution de l’entropie en fonction de la longueur du mot de passe, pour différents pools de caractères (10, 26, 36, 52, 62 et 85).
</p>

<p>
On constate que, pour tous les pools, l’entropie augmente de manière quasi linéaire avec la longueur du mot de passe. Chaque caractère supplémentaire apporte 
un gain significatif en sécurité, surtout lorsque le pool est important.
</p>

<p>Par ailleurs, pour une longueur donnée, plus le pool est grand, plus l’entropie est élevée. Les courbes correspondant aux grands pools (62 et 85 caractères) sont 
nettement au-dessus de celles des petits pools (10 ou 26). Cela confirme que l’ajout de caractères spéciaux, de chiffres et de majuscules améliore fortement la résistance aux attaques.
</p>

</div>
<img src="/Assets/articles/article04 image03.png" alt="Entopie en fonction du nombre de pool">
</div>


<p>
<strong>
Conclusion 
</strong>
</p>

<p>
Ces deux graphiques montrent clairement que la sécurité d’un mot de passe repose principalement sur deux facteurs : sa longueur et la diversité des caractères utilisés. 
L’augmentation de l’un ou de l’autre améliore l’entropie, mais c’est leur combinaison qui produit le gain le plus important.
Ainsi, pour créer des mots de passe réellement robustes, il est recommandé d’utiliser des mots de passe longs, composés d’un large éventail de caractères 
(lettres minuscules et majuscules, chiffres et symboles). Cette approche permet de rendre les attaques par force brute et par dictionnaire beaucoup plus difficiles, voire irréalistes en pratique.
</p>



<p>
De ces éléments, on peut tirer trois propriétés fondamentales d’un mot de passe robuste :
</p>
<p>
  <ul>
  <li>Longueur : chaque caractère supplémentaire augmente exponentiellement l’espace de recherche.</li>
  <li>Diversité du jeu de caractères : une base plus large accroît le nombre de combinaisons possibles.</li>
  <li>Aléa réel : un mot de passe ne doit pas suivre de motifs humains prévisibles ni figurer dans des dictionnaires.</li>
  </ul>
</p>
    
<div class="note">
Les identifiants existants ne sont pas rétroactivement modifiés.
Cette décision vise à éviter toute perturbation des systèmes historiques
dont la stabilité repose sur des configurations validées antérieurement.
</div>
</section>

<section>
<h2>6. Conclusion générale</h2>

<p>
L’obsolescence progressive de certains schémas d’authentification
ne résulte pas d’une défaillance conceptuelle initiale,
mais de l’évolution rapide de l’écosystème technologique.
</p>

<p>
L’approche retenue par l’IFRAS privilégie une transition graduelle,
associant renforcement des politiques pour les nouveaux accès
et maintien contrôlé des configurations existantes.
</p>
</section>

<section>
<h2>Références</h2>
<ul>
  <li>NIST SP 800-63B — Digital Identity Guidelines (2023)</li>
  <li>Veras et al., <em>On the Semantic Patterns of Passwords</em>, IEEE S&P</li>
  <li>IFRAS — Rapport interne sur la résilience des systèmes d’accès (2024)</li>
</ul>
</section>

</main>

<footer>
  <div class="footer-container">
    © IFRAS — Institut Français de Recherche Aéronautique et Spatiale<br>
    Document institutionnel — diffusion contrôlée
  </div>
</footer>

</body>
</html>
